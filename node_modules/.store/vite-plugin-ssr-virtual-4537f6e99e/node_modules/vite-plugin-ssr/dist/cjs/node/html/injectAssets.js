"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectAssetsAfterRender = exports.injectAssetsBeforeRender = exports.injectAssets = exports.injectAssets__public = void 0;
const utils_1 = require("../utils");
const serializePageContextClientSide_1 = require("../serializePageContextClientSide");
const sanitizeJson_1 = require("./injectAssets/sanitizeJson");
const assertPageContextProvidedByUser_1 = require("../../shared/assertPageContextProvidedByUser");
const injectHtmlSnippet_1 = require("./injectAssets/injectHtmlSnippet");
async function injectAssets__public(htmlString, pageContext) {
    (0, utils_1.assertWarning)(false, '`_injectAssets()` is deprecated and will be removed.', { onlyOnce: true });
    (0, utils_1.assertUsage)(typeof htmlString === 'string', '[injectAssets(htmlString, pageContext)]: Argument `htmlString` should be a string.');
    (0, utils_1.assertUsage)(pageContext, '[injectAssets(htmlString, pageContext)]: Argument `pageContext` is missing.');
    const errMsg = (body) => '[injectAssets(htmlString, pageContext)]: ' +
        body +
        '. Make sure that `pageContext` is the object that `vite-plugin-ssr` provided to your `render(pageContext)` hook.';
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, 'urlPathname', 'string'), errMsg('`pageContext.urlPathname` should be a string'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_pageId', 'string'), errMsg('`pageContext._pageId` should be a string'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_getPageAssets'), errMsg('`pageContext._getPageAssets` is missing'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_passToClient', 'string[]'), errMsg('`pageContext._passToClient` is missing'));
    (0, utils_1.castProp)(pageContext, '_getPageAssets');
    htmlString = await injectAssets(htmlString, pageContext);
    return htmlString;
}
exports.injectAssets__public = injectAssets__public;
async function injectAssets(htmlString, pageContext) {
    htmlString = await injectAssetsBeforeRender(htmlString, pageContext);
    htmlString = await injectAssetsAfterRender(htmlString, pageContext);
    return htmlString;
}
exports.injectAssets = injectAssets;
async function injectAssetsBeforeRender(htmlString, pageContext) {
    (0, utils_1.assert)(htmlString);
    (0, utils_1.assert)(typeof htmlString === 'string');
    // Ensure existence of `<head>` (Vite's `transformIndexHtml()` is buggy when `<head>` is missing)
    htmlString = (0, injectHtmlSnippet_1.createHtmlHeadIfMissing)(htmlString);
    // Inject Vite transformations
    const { urlPathname } = pageContext;
    (0, utils_1.assert)(typeof urlPathname === 'string' && urlPathname.startsWith('/'));
    htmlString = await applyViteHtmlTransform(htmlString, urlPathname, pageContext);
    if (pageContext._skipAssetInject) {
        return htmlString;
    }
    const pageAssets = await pageContext._getPageAssets();
    const htmlSnippets = [];
    pageAssets.forEach((pageAsset) => {
        const { assetType, preloadType } = pageAsset;
        if (assetType === 'script' || (assetType === 'preload' && preloadType === 'script')) {
            const htmlSnippet = inferAssetTag(pageAsset);
            htmlSnippets.push({ htmlSnippet, position: 'DOCUMENT_END' });
            return;
        }
        if (assetType === 'style' ||
            (assetType === 'preload' && preloadType === 'style') ||
            (assetType === 'preload' && preloadType === 'font')) {
            // In development, Vite automatically inject styles, but we still inject `<link rel="stylesheet" type="text/css" href="${src}">` tags in order to avoid FOUC (flash of unstyled content).
            //   - https://github.com/vitejs/vite/issues/2282
            //   - https://github.com/brillout/vite-plugin-ssr/issues/261
            const htmlSnippet = inferAssetTag(pageAsset);
            htmlSnippets.push({ htmlSnippet, position: 'HEAD_OPENING' });
            return;
        }
        if (assetType === 'preload') {
            const htmlSnippet = inferAssetTag(pageAsset);
            htmlSnippets.push({ htmlSnippet, position: 'DOCUMENT_END' });
            return;
        }
        (0, utils_1.assert)(false, { assetType, preloadType });
    });
    (0, utils_1.assert)(htmlSnippets.every(({ htmlSnippet }) => htmlSnippet.startsWith('<') && htmlSnippet.endsWith('>')));
    ['HEAD_OPENING', 'HEAD_CLOSING', 'DOCUMENT_END'].forEach((position) => {
        htmlString = (0, injectHtmlSnippet_1.injectHtmlSnippet)(position, htmlSnippets
            .filter((h) => h.position === position)
            .map((h) => h.htmlSnippet)
            .join(''), htmlString);
    });
    return htmlString;
}
exports.injectAssetsBeforeRender = injectAssetsBeforeRender;
async function injectAssetsAfterRender(htmlString, pageContext) {
    // Inject pageContext__client
    (0, utils_1.assertUsage)(!injectPageInfoAlreadyDone(htmlString), 'Assets are being injected twice into your HTML. Make sure to remove your superfluous `injectAssets()` call (`vite-plugin-ssr` already automatically calls `injectAssets()`).');
    if (pageContext._pageContextProvidedByUserPromise !== null) {
        const pageContextProvidedByUser = await pageContext._pageContextProvidedByUserPromise;
        (0, assertPageContextProvidedByUser_1.assertPageContextProvidedByUser)(pageContextProvidedByUser, { hook: pageContext._renderHook });
        Object.assign(pageContext, pageContextProvidedByUser);
    }
    if (pageContext._skipAssetInject) {
        return htmlString;
    }
    if (!pageContext._isHtmlOnly) {
        htmlString = injectPageContext(htmlString, pageContext);
    }
    return htmlString;
}
exports.injectAssetsAfterRender = injectAssetsAfterRender;
async function applyViteHtmlTransform(htmlString, urlPathname, pageContext) {
    if (pageContext._isProduction) {
        return htmlString;
    }
    (0, utils_1.assert)(pageContext._viteDevServer);
    htmlString = await pageContext._viteDevServer.transformIndexHtml(urlPathname, htmlString);
    htmlString = removeDuplicatedBaseUrl(htmlString, pageContext._baseUrl);
    return htmlString;
}
function removeDuplicatedBaseUrl(htmlString, baseUrl) {
    // Proper fix is to add Vite option to skip this: https://github.com/vitejs/vite/blob/aaa26a32501c857d854e9d9daca2a88a9e086392/packages/vite/src/node/server/middlewares/indexHtml.ts#L62-L67
    const baseUrlNormalized = (0, utils_1.normalizeBaseUrl)(baseUrl);
    if (baseUrlNormalized === '/') {
        return htmlString;
    }
    (0, utils_1.assert)(!baseUrlNormalized.endsWith('/'));
    htmlString = htmlString.split(baseUrlNormalized + baseUrlNormalized).join(baseUrlNormalized);
    return htmlString;
}
const pageInfoInjectionBegin = '<script id="vite-plugin-ssr_pageContext" type="application/json">';
function injectPageContext(htmlString, pageContext) {
    const pageContextSerialized = (0, sanitizeJson_1.sanitizeJson)((0, serializePageContextClientSide_1.serializePageContextClientSide)(pageContext));
    const htmlSnippet = `${pageInfoInjectionBegin}${pageContextSerialized}</script>`;
    htmlString = (0, injectHtmlSnippet_1.injectHtmlSnippet)('DOCUMENT_END', htmlSnippet, htmlString);
    return htmlString;
}
function injectPageInfoAlreadyDone(htmlString) {
    return htmlString.includes(pageInfoInjectionBegin);
}
function inferAssetTag(pageAsset) {
    const { src, assetType, mediaType, preloadType } = pageAsset;
    if (assetType === 'script') {
        (0, utils_1.assert)(mediaType === 'text/javascript');
        return `<script type="module" src="${src}"></script>`;
    }
    if (assetType === 'style') {
        // CSS has highest priority.
        // Would there be any advantage of using a preload tag for a css file instead of loading it right away?
        return `<link rel="stylesheet" type="text/css" href="${src}">`;
    }
    if (assetType === 'preload') {
        if (preloadType === 'font') {
            // `crossorigin` is needed for fonts, see https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload#cors-enabled_fetches
            return `<link rel="preload" as="font" crossorigin type="${mediaType}" href="${src}">`;
        }
        if (preloadType === 'script') {
            (0, utils_1.assert)(mediaType === 'text/javascript');
            return `<link rel="modulepreload" as="script" type="${mediaType}" href="${src}">`;
        }
        const attributeAs = !preloadType ? '' : ` as="${preloadType}"`;
        const attributeType = !mediaType ? '' : ` type="${mediaType}"`;
        return `<link rel="preload" href="${src}"${attributeAs}${attributeType}>`;
    }
    (0, utils_1.assert)(false);
}
