"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPageFilesServer = exports.renderStatic404Page = exports.prerenderPage = exports.renderPage = void 0;
const route_1 = require("../shared/route");
const renderHtml_1 = require("./html/renderHtml");
const getPageFiles_1 = require("../shared/getPageFiles");
const getHook_1 = require("../shared/getHook");
const pageFilesUtils_1 = require("../shared/pageFilesUtils");
const stringify_1 = require("@brillout/json-s/stringify");
const utils_1 = require("./utils");
const getPageAssets_1 = require("./renderPage/getPageAssets");
const sortPageContext_1 = require("../shared/sortPageContext");
const assertHookResult_1 = require("../shared/assertHookResult");
const stream_1 = require("./html/stream");
const serializePageContextClientSide_1 = require("./serializePageContextClientSide");
const addComputedUrlProps_1 = require("../shared/addComputedUrlProps");
const assertPageContextProvidedByUser_1 = require("../shared/assertPageContextProvidedByUser");
const RenderErrorPage_1 = require("./renderPage/RenderErrorPage");
const warn404_1 = require("./renderPage/warn404");
const globalContext_1 = require("./globalContext");
const viteLogging_1 = require("./viteLogging");
async function renderPage_(pageContextInit) {
    assertArguments(...arguments);
    const pageContext = await initializePageContext(pageContextInit);
    if ('httpResponse' in pageContext) {
        (0, utils_1.assert)(pageContext.httpResponse === null);
        return pageContext;
    }
    // *** Route ***
    const routeResult = await (0, route_1.route)(pageContext);
    // TODO: remove unnecessary extra error handling?
    if ('hookError' in routeResult) {
        const err = routeResult.hookError;
        logError(err);
        return await renderErrorPage(pageContextInit, routeResult.hookError);
    }
    (0, utils_1.objectAssign)(pageContext, routeResult.pageContextAddendum);
    // *** Handle 404 ***
    let statusCode;
    if ((0, utils_1.hasProp)(pageContext, '_pageId', 'string')) {
        statusCode = 200;
    }
    else {
        (0, utils_1.assert)(pageContext._pageId === null);
        (0, warn404_1.warn404)(pageContext);
        if (!pageContext._isPageContextRequest) {
            statusCode = 404;
        }
        else {
            statusCode = 200;
        }
        const errorWhileRendering = null;
        // No `_error.page.js` is defined
        const errorPageId = (0, route_1.getErrorPageId)(pageContext._allPageIds);
        if (!errorPageId) {
            warnMissingErrorPage(pageContext);
            if (pageContext._isPageContextRequest) {
                const httpResponse = createHttpResponseObject((0, stringify_1.stringify)({
                    pageContext404PageDoesNotExist: true,
                }), {
                    statusCode,
                    renderFilePath: null,
                }, pageContext);
                (0, utils_1.objectAssign)(pageContext, { httpResponse, errorWhileRendering });
                return pageContext;
            }
            else {
                const httpResponse = null;
                (0, utils_1.objectAssign)(pageContext, { httpResponse, errorWhileRendering });
                return pageContext;
            }
        }
        // Render 404 page
        (0, utils_1.objectAssign)(pageContext, {
            _pageId: errorPageId,
            is404: true,
            errorWhileRendering,
        });
    }
    const pageFiles = await loadPageFilesServer(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    await executeOnBeforeRenderHooks(pageContext);
    if (pageContext._isPageContextRequest) {
        const pageContextSerialized = (0, serializePageContextClientSide_1.serializePageContextClientSide)(pageContext);
        const httpResponse = createHttpResponseObject(pageContextSerialized, { statusCode: 200, renderFilePath: null }, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse, errorWhileRendering: null });
        return pageContext;
    }
    const renderHookResult = await executeRenderHook(pageContext);
    if (renderHookResult.htmlRender === null) {
        (0, utils_1.objectAssign)(pageContext, { httpResponse: null, errorWhileRendering: null });
        return pageContext;
    }
    else {
        const { htmlRender, renderFilePath } = renderHookResult;
        const httpResponse = createHttpResponseObject(htmlRender, { statusCode, renderFilePath }, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse, errorWhileRendering: null });
        return pageContext;
    }
}
async function initializePageContext(pageContextInit) {
    const pageContext = Object.assign({ _isPreRendering: false }, pageContextInit);
    if (pageContext.url.endsWith('/favicon.ico') || !(0, utils_1.isParsable)(pageContext.url)) {
        (0, utils_1.objectAssign)(pageContext, { httpResponse: null, errorWhileRendering: null });
        return pageContext;
    }
    const globalContext = await (0, globalContext_1.getGlobalContext)(pageContext._isPreRendering);
    (0, utils_1.objectAssign)(pageContext, globalContext);
    {
        const { pageFilesAll, allPageIds } = await (0, getPageFiles_1.getPageFilesAllServerSide)(globalContext._isProduction);
        (0, utils_1.objectAssign)(pageContext, {
            _pageFilesAll: pageFilesAll,
            _allPageIds: allPageIds,
        });
    }
    {
        const { url } = pageContext;
        (0, utils_1.assert)(url.startsWith('/') || url.startsWith('http'));
        const { urlWithoutPageContextRequestSuffix, isPageContextRequest } = (0, utils_1.handlePageContextRequestSuffix)(url);
        const { hasBaseUrl } = (0, utils_1.parseUrl)(urlWithoutPageContextRequestSuffix, globalContext._baseUrl);
        if (!hasBaseUrl) {
            (0, utils_1.objectAssign)(pageContext, { httpResponse: null, errorWhileRendering: null });
            return pageContext;
        }
        (0, utils_1.objectAssign)(pageContext, {
            _isPageContextRequest: isPageContextRequest,
            _urlProcessor: (url) => (0, utils_1.handlePageContextRequestSuffix)(url).urlWithoutPageContextRequestSuffix,
        });
    }
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    return pageContext;
}
// `renderPage()` calls `renderPage_()` while ensuring an `err` is always `console.error(err)` instead of `throw err`, so that `vite-plugin-ssr` never triggers a server shut down. (Throwing an error in an Express.js middleware shuts down the whole Express.js server.)
async function renderPage(pageContextInit) {
    const args = arguments;
    try {
        return await renderPage_.apply(null, args);
    }
    catch (err) {
        assertError(err);
        const skipLog = (0, RenderErrorPage_1.isRenderErrorPage)(err);
        if (!skipLog) {
            logError(err);
        }
        else {
            setAlreadyLogged(err);
        }
        try {
            const pageContextAddendum = {};
            if ((0, RenderErrorPage_1.isRenderErrorPage)(err)) {
                (0, utils_1.objectAssign)(pageContextAddendum, { is404: true });
                (0, utils_1.objectAssign)(pageContextAddendum, err.pageContext);
            }
            return await renderErrorPage(pageContextInit, err, pageContextAddendum);
        }
        catch (err2) {
            assertError(err2);
            // We swallow `err2`; logging `err` should be enough; `err2` is likely the same error than `err` anyways.
            if (skipLog) {
                logError(err2);
            }
            const pageContext = {};
            (0, utils_1.objectAssign)(pageContext, pageContextInit);
            (0, utils_1.objectAssign)(pageContext, {
                httpResponse: null,
                errorWhileRendering: err,
            });
            return pageContext;
        }
    }
}
exports.renderPage = renderPage;
async function renderErrorPage(pageContextInit, err, pageContextAddendum) {
    (0, utils_1.assert)(hasAlreadyLogged(err));
    const pageContext = await initializePageContext(pageContextInit);
    // `pageContext.httpResponse===null` should have already been handled in `renderPage()`
    (0, utils_1.assert)(!('httpResponse' in pageContext));
    (0, utils_1.objectAssign)(pageContext, {
        is404: false,
        errorWhileRendering: err,
        httpResponse: null,
        routeParams: {},
    });
    (0, utils_1.objectAssign)(pageContext, pageContextAddendum);
    const statusCode = pageContext.is404 ? 404 : 500;
    if (pageContext._isPageContextRequest) {
        const body = (0, stringify_1.stringify)({
            serverSideError: true,
        });
        const httpResponse = createHttpResponseObject(body, { statusCode, renderFilePath: null }, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
    const errorPageId = (0, route_1.getErrorPageId)(pageContext._allPageIds);
    if (errorPageId === null) {
        warnMissingErrorPage(pageContext);
        return pageContext;
    }
    (0, utils_1.objectAssign)(pageContext, {
        _pageId: errorPageId,
    });
    const pageFiles = await loadPageFilesServer(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    await executeOnBeforeRenderHooks(pageContext);
    const renderHookResult = await executeRenderHook(pageContext);
    const { htmlRender, renderFilePath } = renderHookResult;
    const httpResponse = createHttpResponseObject(htmlRender, { statusCode, renderFilePath }, pageContext);
    (0, utils_1.objectAssign)(pageContext, { httpResponse });
    return pageContext;
}
function assertError(err) {
    (0, RenderErrorPage_1.assertRenderErrorPageParentheses)(err);
}
function createHttpResponseObject(htmlRender, { statusCode, renderFilePath }, pageContext) {
    if (htmlRender === null) {
        return null;
    }
    (0, utils_1.assert)(!pageContext._isPageContextRequest || typeof htmlRender === 'string');
    return {
        statusCode,
        contentType: pageContext._isPageContextRequest ? 'application/json' : 'text/html',
        get body() {
            if (typeof htmlRender !== 'string') {
                (0, utils_1.assert)(renderFilePath);
                (0, utils_1.assertUsage)(false, errMsg('body', 'Use `const body = await pageContext.httpResponse.getBody()` instead.'));
            }
            const body = htmlRender;
            return body;
        },
        async getBody() {
            const body = await (0, renderHtml_1.getHtmlString)(htmlRender);
            return body;
        },
        async getNodeStream() {
            const nodeStream = await (0, stream_1.getStreamReadableNode)(htmlRender);
            (0, utils_1.assertUsage)(nodeStream !== null, errMsg('getNodeStream()', fixMsg('readable', 'node')));
            return nodeStream;
        },
        async getWebStream() {
            const webStream = await (0, stream_1.getStreamReadableWeb)(htmlRender);
            (0, utils_1.assertUsage)(webStream !== null, errMsg('getWebStream()', fixMsg('readable', 'web')));
            return webStream;
        },
        pipeToWebWritable(writable) {
            const success = (0, stream_1.pipeToStreamWritableWeb)(htmlRender, writable);
            (0, utils_1.assertUsage)(success, errMsg('pipeToWebWritable()', fixMsg('pipe', 'web')));
        },
        pipeToNodeWritable(writable) {
            const success = (0, stream_1.pipeToStreamWritableNode)(htmlRender, writable);
            (0, utils_1.assertUsage)(success, errMsg('pipeToNodeWritable()', fixMsg('pipe', 'node')));
        },
    };
    function errMsg(method, fixMsg) {
        (0, utils_1.assert)(typeof htmlRender === 'string' || (0, stream_1.isStream)(htmlRender));
        let htmlTypeName = 'an HTML string';
        if ((0, stream_1.isStream)(htmlRender)) {
            htmlTypeName = (0, stream_1.inferStreamName)(htmlRender);
        }
        return `\`pageContext.httpResponse.${method}\` is not available because your \`render()\` hook (${renderFilePath}) provides ${htmlTypeName}. ${fixMsg}. See https://vite-plugin-ssr.com/stream`;
    }
    function fixMsg(type, standard) {
        return `Make sure your \`render()\` hook provides ${(0, stream_1.getStreamName)(type, standard)} instead.`;
    }
}
async function prerenderPage(pageContext) {
    (0, utils_1.assert)(pageContext._isPreRendering === true);
    (0, utils_1.objectAssign)(pageContext, {
        _isPageContextRequest: false,
        _urlProcessor: null,
    });
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    await executeOnBeforeRenderHooks(pageContext);
    const renderHookResult = await executeRenderHook(pageContext);
    (0, utils_1.assertUsage)(renderHookResult.htmlRender !== null, `Cannot pre-render \`${pageContext.url}\` because the \`render()\` hook exported by ${renderHookResult.renderFilePath} didn't return an HTML string.`);
    (0, utils_1.assert)(pageContext._isPageContextRequest === false);
    const documentHtml = await (0, renderHtml_1.getHtmlString)(renderHookResult.htmlRender);
    (0, utils_1.assert)(typeof documentHtml === 'string');
    if (!pageContext._usesClientRouter) {
        return { documentHtml, pageContextSerialized: null, pageContext };
    }
    else {
        const pageContextSerialized = (0, serializePageContextClientSide_1.serializePageContextClientSide)(pageContext);
        return { documentHtml, pageContextSerialized, pageContext };
    }
}
exports.prerenderPage = prerenderPage;
async function renderStatic404Page(globalContext) {
    const errorPageId = (0, route_1.getErrorPageId)(globalContext._allPageIds);
    if (!errorPageId) {
        return null;
    }
    const pageContext = Object.assign(Object.assign({}, globalContext), { _pageId: errorPageId, is404: true, routeParams: {}, url: '/fake-404-url', 
        // `renderStatic404Page()` is about generating `dist/client/404.html` for static hosts; there is no Client Routing.
        _usesClientRouter: false });
    const pageFiles = await loadPageFilesServer(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    return prerenderPage(pageContext);
}
exports.renderStatic404Page = renderStatic404Page;
function preparePageContextForRelease(pageContext) {
    (0, utils_1.assert)(typeof pageContext.url === 'string');
    (0, utils_1.assert)(typeof pageContext.urlPathname === 'string');
    (0, utils_1.assert)((0, utils_1.isPlainObject)(pageContext.urlParsed));
    (0, utils_1.assert)((0, utils_1.isPlainObject)(pageContext.routeParams));
    (0, utils_1.assert)('Page' in pageContext);
    (0, utils_1.assert)((0, utils_1.isObject)(pageContext.pageExports));
    (0, utils_1.assert)((0, utils_1.isObject)(pageContext.exports));
    (0, utils_1.assert)((0, utils_1.isObject)(pageContext.exportsAll));
    (0, sortPageContext_1.sortPageContext)(pageContext);
    if ((0, route_1.isErrorPage)(pageContext._pageId)) {
        (0, utils_1.assert)((0, utils_1.hasProp)(pageContext, 'is404', 'boolean'));
        (0, serializePageContextClientSide_1.addIs404ToPageProps)(pageContext);
    }
}
async function loadPageFilesServer(pageContext) {
    var _a, _b;
    const [pageContextAddendum] = await Promise.all([
        (0, getPageFiles_1.loadPageFiles)(pageContext._pageFilesAll, pageContext._pageId, false),
        loadPageFilesClientExportNames(pageContext._pageFilesAll, pageContext._pageId),
    ]);
    const { clientEntries, clientDependencies, isHtmlOnly } = getClientEntries(pageContext._pageFilesAll, pageContext._pageId);
    (0, utils_1.objectAssign)(pageContextAddendum, {
        _passToClient: (0, getPageFiles_1.getStringUnion)(pageContextAddendum.exportsAll, 'passToClient'),
        _isHtmlOnly: isHtmlOnly,
    });
    (0, utils_1.objectAssign)(pageContextAddendum, {
        Page: (_b = (_a = pageContextAddendum.exports.Page) !== null && _a !== void 0 ? _a : pageContextAddendum.exports.default) !== null && _b !== void 0 ? _b : null,
    });
    const isPreRendering = pageContext._isPreRendering;
    (0, utils_1.assert)([true, false].includes(isPreRendering));
    clientDependencies.push(...pageContext._pageFilesAll
        .filter((p) => 
    // Add CSS assets
    //  - `.page.server.js` files are transformed by `?extractStyles`
    p.fileType === '.page.server' && p.isRelevant(pageContext._pageId))
        .map((p) => ({ id: p.filePath, onlyAssets: true })));
    (0, utils_1.objectAssign)(pageContextAddendum, {
        _getPageAssets: async () => {
            const pageAssets = await (0, getPageAssets_1.getPageAssets)(pageContext, clientDependencies, clientEntries, isPreRendering);
            return pageAssets;
        },
    });
    return pageContextAddendum;
}
exports.loadPageFilesServer = loadPageFilesServer;
async function loadPageFilesClientExportNames(pageFilesAll, pageId) {
    await Promise.all(pageFilesAll.filter((p) => p.fileType === '.page.client' && p.isRelevant(pageId)).map((p) => { var _a; return (_a = p.loadExportNames) === null || _a === void 0 ? void 0 : _a.call(p); }));
}
function getClientEntries(pageFilesAll, pageId) {
    const clientEntries = [];
    const pageFilesClient = [];
    const clientDependencies = [];
    const { isHtmlOnly, pageFilesClientCandidates } = (0, pageFilesUtils_1.isHtmlOnlyPage)(pageId, pageFilesAll, false);
    {
        // Include all `.page.client.js` files that don't `export { render }` nor `export { Page }`/`export default`
        //  - Also for HTML-only pages; allowing the user to add client-side JavaScript while skipping the heavy `render()` hook's dependencies.
        //  - We only include page files with `export { Page }`/`export default` if we have a `render()` hook.
        const pageFilesClientNonRender = pageFilesClientCandidates.filter((p) => !(0, pageFilesUtils_1.getExportNames)(p, false).includes('render') && !(0, pageFilesUtils_1.hasPageExport)(p, false));
        pageFilesClient.push(...pageFilesClientNonRender);
    }
    // Handle SPA & SSR client
    {
        if (!isHtmlOnly) {
            // Add the `.page.client.js` file that has `export { render }`
            //  - The filesystem-nearest one
            //  - This means automatic override: only one `render()` hook is loaded and all other `.page.client.js` are dismissed
            {
                const pageFileRender = pageFilesClientCandidates.filter((p) => (0, pageFilesUtils_1.getExportNames)(p, false).includes('render'))[0];
                (0, utils_1.assert)(pageFileRender);
                pageFilesClient.push(pageFileRender);
                const pageFilePageExport = pageFilesClientCandidates.filter((p) => (0, pageFilesUtils_1.hasPageExport)(p, false))[0];
                (0, utils_1.assert)(pageFilePageExport);
                pageFilesClient.push(pageFilePageExport);
            }
            // Add the vps client entry
            {
                const usesClientRouting = pageFilesClient.some((p) => (0, pageFilesUtils_1.getExportNames)(p, false).includes('clientRouting'));
                const clientEntry = usesClientRouting
                    ? // $userRoot/dist/client/entry-client-routing.js
                        '@@vite-plugin-ssr/dist/esm/client/router/entry.js'
                    : // $userRoot/dist/client/entry-server-routing.js
                        '@@vite-plugin-ssr/dist/esm/client/entry.js';
                clientEntries.push(clientEntry);
                clientDependencies.push({ id: clientEntry, onlyAssets: false });
            }
        }
        else {
            // There is no vps client entry; we directly load the user's `.page.client.js` files
            //  - There is no `render()` hook; so there is no need for `pageContext` (nor `pageContext.exports`).
            clientEntries.push(...pageFilesClient.map((p) => p.filePath)); // Only includes page files that have no `export { render }` and no `export { Page }`/`export default`
            // Add CSS/assets of pages files that `export { Page }`/`export default`
            const pageFilesPageExport = pageFilesClientCandidates.filter((p) => (0, pageFilesUtils_1.hasPageExport)(p, false));
            clientDependencies.push(...pageFilesPageExport.map((p) => ({ id: p.filePath, onlyAssets: true })));
        }
    }
    clientDependencies.push(...pageFilesClient.map((p) => ({ id: p.filePath, onlyAssets: false })));
    // console.log(pageId, pageFilesClientCandidates, clientEntries, clientDependencies)
    return { clientEntries, clientDependencies, isHtmlOnly };
}
async function executeOnBeforeRenderHooks(pageContext) {
    if (pageContext._pageContextAlreadyProvidedByPrerenderHook) {
        return;
    }
    const hook = (0, getHook_1.getHook)(pageContext, 'onBeforeRender');
    if (!hook) {
        return;
    }
    const onBeforeRender = hook.hook;
    preparePageContextForRelease(pageContext);
    const hookResult = await onBeforeRender(pageContext);
    (0, assertHookResult_1.assertHookResult)(hookResult, 'onBeforeRender', ['pageContext'], hook.filePath);
    const pageContextFromHook = hookResult === null || hookResult === void 0 ? void 0 : hookResult.pageContext;
    Object.assign(pageContext, pageContextFromHook);
}
async function executeRenderHook(pageContext) {
    const hook = (0, getHook_1.getHook)(pageContext, 'render');
    (0, utils_1.assertUsage)(hook, 'No `render()` hook found. Make sure to define a `*.page.server.js` file with `export function render() { /*...*/ }`. You can also `export { render }` in `_default.page.server.js` which will be the default `render()` hook of all your pages.');
    const render = hook.hook;
    const renderFilePath = hook.filePath;
    preparePageContextForRelease(pageContext);
    const result = await render(pageContext);
    if ((0, utils_1.isObject)(result) && !(0, renderHtml_1.isDocumentHtml)(result)) {
        (0, assertHookResult_1.assertHookResult)(result, 'render', ['documentHtml', 'pageContext'], renderFilePath);
    }
    (0, utils_1.objectAssign)(pageContext, { _renderHook: { hookFilePath: renderFilePath, hookName: 'render' } });
    let pageContextPromise = null;
    if ((0, utils_1.hasProp)(result, 'pageContext')) {
        const pageContextProvidedByUser = result.pageContext;
        if ((0, utils_1.isPromise)(pageContextProvidedByUser)) {
            pageContextPromise = pageContextProvidedByUser;
        }
        else {
            (0, assertPageContextProvidedByUser_1.assertPageContextProvidedByUser)(pageContextProvidedByUser, { hook: pageContext._renderHook });
            Object.assign(pageContext, pageContextProvidedByUser);
        }
    }
    (0, utils_1.objectAssign)(pageContext, { _pageContextProvidedByUserPromise: pageContextPromise });
    const errPrefix = 'The `render()` hook exported by ' + renderFilePath;
    const errSuffix = [
        'a string generated with the `escapeInject` template tag or a string returned by `dangerouslySkipEscape()`,',
        'see https://vite-plugin-ssr.com/escapeInject',
    ].join(' ');
    let documentHtml;
    if (!(0, utils_1.isObject)(result) || (0, renderHtml_1.isDocumentHtml)(result)) {
        (0, utils_1.assertUsage)(typeof result !== 'string', [
            errPrefix,
            'returned a plain JavaScript string which is forbidden;',
            'instead, it should return',
            errSuffix,
        ].join(' '));
        (0, utils_1.assertUsage)(result === null || (0, renderHtml_1.isDocumentHtml)(result), [
            errPrefix,
            'should return `null`, a string `documentHtml`, or an object `{ documentHtml, pageContext }`',
            'where `pageContext` is `undefined` or an object holding additional `pageContext` values',
            'and `documentHtml` is',
            errSuffix,
        ].join(' '));
        documentHtml = result;
    }
    else {
        (0, assertHookResult_1.assertObjectKeys)(result, ['documentHtml', 'pageContext'], errPrefix);
        if ('documentHtml' in result) {
            documentHtml = result.documentHtml;
            (0, utils_1.assertUsage)(typeof documentHtml !== 'string', [
                errPrefix,
                'returned `{ documentHtml }`, but `documentHtml` is a plain JavaScript string which is forbidden;',
                '`documentHtml` should be',
                errSuffix,
            ].join(' '));
            (0, utils_1.assertUsage)(documentHtml === undefined || documentHtml === null || (0, renderHtml_1.isDocumentHtml)(documentHtml), [errPrefix, 'returned `{ documentHtml }`, but `documentHtml` should be', errSuffix].join(' '));
        }
    }
    (0, utils_1.assert)(documentHtml === undefined || documentHtml === null || (0, renderHtml_1.isDocumentHtml)(documentHtml));
    if (documentHtml === null || documentHtml === undefined) {
        return { htmlRender: null, renderFilePath };
    }
    const onErrorWhileStreaming = (err) => {
        assertError(err);
        logError(err);
        (0, utils_1.objectAssign)(pageContext, {
            errorWhileRendering: err,
            _serverSideErrorWhileStreaming: true,
        });
    };
    const htmlRender = await (0, renderHtml_1.renderHtml)(documentHtml, pageContext, renderFilePath, onErrorWhileStreaming);
    (0, utils_1.assert)(typeof htmlRender === 'string' || (0, stream_1.isStream)(htmlRender));
    return { htmlRender, renderFilePath };
}
function assertArguments(...args) {
    const pageContext = args[0];
    (0, utils_1.assertUsage)(pageContext, '`renderPage(pageContext)`: argument `pageContext` is missing.');
    (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(pageContext), `\`renderPage(pageContext)\`: argument \`pageContext\` should be a plain JavaScript object, but you passed a \`pageContext\` with \`pageContext.constructor === ${pageContext.constructor}\`.`);
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, 'url'), '`renderPage(pageContext)`: The `pageContext` you passed is missing the property `pageContext.url`.');
    (0, utils_1.assertUsage)(typeof pageContext.url === 'string', '`renderPage(pageContext)`: `pageContext.url` should be a string but `typeof pageContext.url === "' +
        typeof pageContext.url +
        '"`.');
    (0, utils_1.assertUsage)(pageContext.url.startsWith('/') || pageContext.url.startsWith('http'), '`renderPage(pageContext)`: `pageContext.url` should start with `/` (e.g. `/product/42`) or `http` (e.g. `http://example.org/product/42`) but `pageContext.url === "' +
        pageContext.url +
        '"`.');
    try {
        const { url } = pageContext;
        const urlWithOrigin = url.startsWith('http') ? url : 'http://fake-origin.example.org' + url;
        // `new URL()` conveniently throws if URL is not an URL
        new URL(urlWithOrigin);
    }
    catch (err) {
        (0, utils_1.assertUsage)(false, '`renderPage(pageContext)`: `pageContext.url` should be a URL but `pageContext.url==="' + pageContext.url + '"`.');
    }
    const len = args.length;
    (0, utils_1.assertUsage)(len === 1, `\`renderPage(pageContext)\`: You passed ${len} arguments but \`renderPage()\` accepts only one argument.'`);
}
function warnMissingErrorPage(pageContext) {
    if (!pageContext._isProduction) {
        (0, utils_1.assertWarning)(false, 'No `_error.page.js` found. We recommend creating a `_error.page.js` file. (This warning is not shown in production.)', { onlyOnce: true });
    }
}
function logError(err) {
    assertError(err);
    if ((0, viteLogging_1.viteAlreadyLoggedError)(err)) {
        return;
    }
    (0, utils_1.assertUsage)((0, utils_1.isObject)(err), 'Your source code threw a primitive value as error (this should never happen). Contact the `vite-plugin-ssr` maintainer to get help.');
    // Avoid logging error twice (not sure if this actually ever happens?)
    if (hasAlreadyLogged(err)) {
        return;
    }
    (0, viteLogging_1.viteErrorCleanup)(err);
    // We ensure we print a string; Cloudflare Workers doesn't seem to properly stringify `Error` objects.
    const errStr = ((0, utils_1.hasProp)(err, 'stack') && String(err.stack)) || String(err);
    console.error(errStr);
    setAlreadyLogged(err);
}
function hasAlreadyLogged(err) {
    (0, utils_1.assert)((0, utils_1.isObject)(err));
    const key = '_wasAlreadyConsoleLogged';
    return err[key] === true;
}
function setAlreadyLogged(err) {
    (0, utils_1.assert)((0, utils_1.isObject)(err));
    const key = '_wasAlreadyConsoleLogged';
    err[key] = true;
}
