"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHtmlHeadIfMissing = exports.injectHtmlSnippet = void 0;
const utils_1 = require("../../utils");
function injectHtmlSnippet(position, htmlSnippet, htmlString) {
    if (position === 'HEAD_OPENING') {
        (0, utils_1.assert)(tagOpeningExists('head', htmlString));
        htmlString = injectAtOpeningTag('head', htmlString, htmlSnippet);
        return htmlString;
    }
    if (position === 'HEAD_CLOSING') {
        (0, utils_1.assert)(tagClosingExists('head', htmlString));
        htmlString = injectAtClosingTag('head', htmlString, htmlSnippet);
        return htmlString;
    }
    if (position === 'DOCUMENT_END') {
        if (tagClosingExists('body', htmlString)) {
            return injectAtClosingTag('body', htmlString, htmlSnippet);
        }
        if (tagClosingExists('html', htmlString)) {
            return injectAtClosingTag('html', htmlString, htmlSnippet);
        }
        return htmlString + '\n' + htmlSnippet;
    }
    (0, utils_1.assert)(false);
}
exports.injectHtmlSnippet = injectHtmlSnippet;
function injectAtOpeningTag(tag, htmlString, htmlSnippet) {
    (0, utils_1.assert)(tagOpeningExists(tag, htmlString));
    const openingTag = getTagOpening(tag);
    const matches = htmlString.match(openingTag);
    (0, utils_1.assert)(matches && matches.length >= 1);
    const tagInstance = matches[0];
    (0, utils_1.assert)(tagInstance);
    const htmlParts = htmlString.split(tagInstance);
    (0, utils_1.assert)(htmlParts.length >= 2);
    // Insert `htmlSnippet` after first `tagInstance`
    const before = (0, utils_1.slice)(htmlParts, 0, 1);
    const after = (0, utils_1.slice)(htmlParts, 1, 0).join(tagInstance);
    return before + tagInstance + htmlSnippet + after;
}
function injectAtClosingTag(tag, htmlString, htmlSnippet) {
    (0, utils_1.assert)(tagClosingExists(tag, htmlString));
    const tagClosing = getTagClosing(tag);
    const htmlParts = htmlString.split(tagClosing);
    (0, utils_1.assert)(htmlParts.length >= 2);
    // Insert `htmlSnippet` before last `tagClosing`
    const before = (0, utils_1.slice)(htmlParts, 0, -1).join(tagClosing);
    const after = (0, utils_1.slice)(htmlParts, -1, 0);
    return before + htmlSnippet + tagClosing + after;
}
function createHtmlHeadIfMissing(htmlString) {
    const assertion = () => (0, utils_1.assert)(tagOpeningExists('head', htmlString) && tagClosingExists('head', htmlString));
    if (tagOpeningExists('head', htmlString) && tagClosingExists('head', htmlString)) {
        assertion();
        return htmlString;
    }
    const htmlSnippet = '<head></head>';
    if (tagOpeningExists('html', htmlString)) {
        htmlString = injectAtOpeningTag('html', htmlString, htmlSnippet);
        assertion();
        return htmlString;
    }
    if (tagOpeningExists('!doctype', htmlString)) {
        htmlString = injectAtOpeningTag('!doctype', htmlString, htmlSnippet);
        assertion();
        return htmlString;
    }
    htmlString = htmlSnippet + '\n' + htmlString;
    assertion();
    return htmlString;
}
exports.createHtmlHeadIfMissing = createHtmlHeadIfMissing;
function tagOpeningExists(tag, htmlString) {
    const tagOpeningRE = getTagOpening(tag);
    return tagOpeningRE.test(htmlString);
}
function tagClosingExists(tag, htmlString) {
    const tagClosing = getTagClosing(tag);
    return htmlString.toLowerCase().includes(tagClosing.toLowerCase());
}
function getTagOpening(tag) {
    const tagOpening = new RegExp(`<${tag}(>| [^>]*>)`, 'i');
    return tagOpening;
}
function getTagClosing(tag) {
    const tagClosing = `</${tag}>`;
    return tagClosing;
}
