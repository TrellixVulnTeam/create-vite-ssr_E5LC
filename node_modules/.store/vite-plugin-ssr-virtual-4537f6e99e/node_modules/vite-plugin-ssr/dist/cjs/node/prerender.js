"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prerender = void 0;
require("./page-files/setup");
const path_1 = require("path");
const route_1 = require("../shared/route");
const utils_1 = require("./utils");
const renderPage_1 = require("./renderPage");
const kolorist_1 = require("kolorist");
const p_limit_1 = __importDefault(require("p-limit"));
const os_1 = require("os");
const getPageFiles_1 = require("../shared/getPageFiles");
const globalContext_1 = require("./globalContext");
const vite_1 = require("vite");
const VitePluginSsrConfig_1 = require("./plugin/plugins/config/VitePluginSsrConfig");
/**
 * Render your pages (e.g. for deploying to a static host).
 * @param partial Allow only a subset of pages to be pre-rendered.
 * @param root The root directory of your project (where `vite.config.js` live) (default: `process.cwd()`).
 * @param outDir The build directory of your project (default: `dist`).
 */
async function prerender(_a = {}) {
    var _b, _c;
    var { onPagePrerender, pageContextInit, configFile } = _a, deprecatedOptions = __rest(_a, ["onPagePrerender", "pageContextInit", "configFile"]);
    checkOutdatedOptions(deprecatedOptions);
    const logLevel = !!onPagePrerender ? 'warn' : 'info';
    if (logLevel === 'info') {
        console.log(`${(0, kolorist_1.cyan)(`vite-plugin-ssr ${utils_1.projectInfo.projectVersion}`)} ${(0, kolorist_1.green)('pre-rendering HTML...')}`);
    }
    setProductionEnvVar();
    const viteConfig = await (0, vite_1.resolveConfig)({ configFile }, 'build', 'production');
    const { root, build: { outDir }, } = viteConfig;
    (0, utils_1.assertUsage)(viteConfig.configFile, `Could not find \`vite.config.js\` at ${root}. Use the option \`prerender({ configFile: 'path/to/vite.config.js' })\`.`);
    (0, utils_1.assertUsage)(viteConfig.plugins.some((p) => { var _a; return (_a = p.name) === null || _a === void 0 ? void 0 : _a.startsWith('vite-plugin-ssr'); }), `The \`vite.config.js\` (${viteConfig.configFile}) does not contain vite-plugin-ssr. Make sure to add vite-plugin-ssr to \`vite.config.js\` or, if you have more than one \`vite.config.js\`, use the option \`prerender({ configFile: 'path/to/vite.config.js' })\` to select the right \`vite.config.js\`.`);
    (0, VitePluginSsrConfig_1.assertVitePluginSsrConfig)(viteConfig);
    const { partial = false, noExtraDir = false, parallel = (0, os_1.cpus)().length || 1, } = (_c = (_b = viteConfig.vitePluginSsr) === null || _b === void 0 ? void 0 : _b.prerender) !== null && _c !== void 0 ? _c : {};
    const concurrencyLimit = (0, p_limit_1.default)(parallel);
    const globalContext = await (0, globalContext_1.getGlobalContext)(true);
    (0, utils_1.objectAssign)(globalContext, {
        _isPreRendering: true,
        _urlProcessor: null,
        _noExtraDir: noExtraDir !== null && noExtraDir !== void 0 ? noExtraDir : false,
        _root: root,
        prerenderPageContexts: [],
    });
    (0, utils_1.assert)(globalContext._isProduction);
    (0, utils_1.objectAssign)(globalContext, {
        _usesClientRouter: globalContext._manifestPlugin.usesClientRouter,
    });
    {
        const { pageFilesAll, allPageIds } = await (0, getPageFiles_1.getPageFilesAllServerSide)(globalContext._isProduction);
        (0, utils_1.objectAssign)(globalContext, {
            _pageFilesAll: pageFilesAll,
            _allPageIds: allPageIds,
        });
    }
    (0, utils_1.objectAssign)(globalContext, pageContextInit);
    const doNotPrerenderList = [];
    await callPrerenderHooks(globalContext, doNotPrerenderList, concurrencyLimit);
    await handlePagesWithStaticRoutes(globalContext, doNotPrerenderList, concurrencyLimit);
    await callOnBeforePrerenderHook(globalContext);
    const prerenderPageIds = {};
    const htmlFiles = [];
    await routeAndPrerender(globalContext, htmlFiles, prerenderPageIds, concurrencyLimit);
    warnContradictoryNoPrerenderList(prerenderPageIds, doNotPrerenderList);
    await prerender404Page(htmlFiles, globalContext);
    if (logLevel === 'info') {
        console.log(`${(0, kolorist_1.green)(`âœ“`)} ${htmlFiles.length} HTML documents pre-rendered.`);
    }
    await Promise.all(htmlFiles.map((htmlFile) => writeHtmlFile(htmlFile, root, outDir, doNotPrerenderList, concurrencyLimit, onPagePrerender, logLevel)));
    warnMissingPages(prerenderPageIds, doNotPrerenderList, globalContext, partial);
}
exports.prerender = prerender;
async function callPrerenderHooks(globalContext, doNotPrerenderList, concurrencyLimit) {
    // Render URLs returned by `prerender()` hooks
    await Promise.all(globalContext._pageFilesAll
        .filter((p) => p.fileType === '.page.server')
        .map((p) => concurrencyLimit(async () => {
        var _a, _b, _c;
        await ((_a = p.loadFile) === null || _a === void 0 ? void 0 : _a.call(p));
        if ((_b = p.fileExports) === null || _b === void 0 ? void 0 : _b.doNotPrerender) {
            doNotPrerenderList.push({ pageId: p.pageId, pageServerFilePath: p.filePath });
            return;
        }
        const prerender = (_c = p.fileExports) === null || _c === void 0 ? void 0 : _c.prerender;
        if (!prerender)
            return;
        (0, utils_1.assertUsage)((0, utils_1.isCallable)(prerender), `\`export { prerender }\` of ${p.filePath} should be a function.`);
        const prerenderSourceFile = p.filePath;
        (0, utils_1.assert)(prerenderSourceFile);
        let prerenderResult;
        try {
            prerenderResult = await prerender();
        }
        catch (err) {
            throwPrerenderError(err);
            (0, utils_1.assert)(false);
        }
        const result = normalizePrerenderResult(prerenderResult, prerenderSourceFile);
        result.forEach(({ url, pageContext }) => {
            (0, utils_1.assert)(typeof url === 'string');
            (0, utils_1.assert)(url.startsWith('/'));
            (0, utils_1.assert)(pageContext === null || (0, utils_1.isPlainObject)(pageContext));
            let pageContextFound = globalContext.prerenderPageContexts.find((pageContext) => pageContext.url === url);
            if (!pageContextFound) {
                pageContextFound = Object.assign(Object.assign({}, globalContext), { _prerenderSourceFile: prerenderSourceFile, url });
                globalContext.prerenderPageContexts.push(pageContextFound);
            }
            if (pageContext) {
                (0, utils_1.objectAssign)(pageContextFound, Object.assign({ _pageContextAlreadyProvidedByPrerenderHook: true }, pageContext));
            }
        });
    })));
}
async function handlePagesWithStaticRoutes(globalContext, doNotPrerenderList, concurrencyLimit) {
    // Pre-render pages with a static route
    const { pageRoutes } = await (0, route_1.loadPageRoutes)(globalContext);
    await Promise.all(pageRoutes.map((pageRoute) => concurrencyLimit(async () => {
        const { pageId } = pageRoute;
        if (doNotPrerenderList.find((p) => p.pageId === pageId)) {
            return;
        }
        let url;
        if (pageRoute.pageRouteFile) {
            const { routeValue } = pageRoute.pageRouteFile;
            if (typeof routeValue === 'string' && (0, route_1.isStaticRoute)(routeValue)) {
                (0, utils_1.assert)(routeValue.startsWith('/'));
                url = routeValue;
            }
            else {
                // Abort since the page's route is a Route Function or parameterized Route String
                return;
            }
        }
        else {
            url = pageRoute.filesystemRoute;
        }
        (0, utils_1.assert)(url.startsWith('/'));
        // Already included in a `prerender()` hook
        if (globalContext.prerenderPageContexts.find((pageContext) => pageContext.url === url)) {
            // Not sure if there is a use case for it, but why not allowing users to use a `prerender()` hook in order to provide some `pageContext` for a page with a static route
            return;
        }
        const pageContext = Object.assign(Object.assign({}, globalContext), { _prerenderSourceFile: null, url, routeParams: {}, _pageId: pageId });
        (0, utils_1.objectAssign)(pageContext, await (0, renderPage_1.loadPageFilesServer)(pageContext));
        globalContext.prerenderPageContexts.push(pageContext);
    })));
}
async function callOnBeforePrerenderHook(globalContext) {
    const pageFilesServerDefault = globalContext._pageFilesAll.filter((p) => p.fileType === '.page.server' && p.isDefaultPageFile);
    await Promise.all(pageFilesServerDefault.map((p) => { var _a; return (_a = p.loadFile) === null || _a === void 0 ? void 0 : _a.call(p); }));
    const hooks = pageFilesServerDefault
        .filter((p) => { var _a; return (_a = p.fileExports) === null || _a === void 0 ? void 0 : _a.onBeforePrerender; })
        .map((p) => ({ filePath: p.filePath, onBeforePrerender: p.fileExports.onBeforePrerender }));
    if (hooks.length === 0) {
        return;
    }
    (0, utils_1.assertUsage)(hooks.length === 1, 'There can be only one `onBeforePrerender()` hook. If you need to be able to define several, open a new GitHub issue.');
    const hook = hooks[0];
    const { onBeforePrerender, filePath } = hook;
    (0, utils_1.assertUsage)((0, utils_1.isCallable)(onBeforePrerender), `\`export { onBeforePrerender }\` of ${filePath} should be a function.`);
    const result = await onBeforePrerender(globalContext);
    if (result === null || result === undefined) {
        return;
    }
    const errPrefix = `The \`onBeforePrerender()\` hook exported by \`${filePath}\``;
    (0, utils_1.assertUsage)((0, utils_1.isObjectWithKeys)(result, ['globalContext']) && (0, utils_1.hasProp)(result, 'globalContext'), `${errPrefix} should return \`null\`, \`undefined\`, or a plain JavaScript object \`{ globalContext: { /* ... */ } }\`.`);
    const globalContextAddedum = result.globalContext;
    (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(globalContextAddedum), `${errPrefix} returned \`{ globalContext }\` but \`globalContext\` should be a plain JavaScript object.`);
    (0, utils_1.objectAssign)(globalContext, globalContextAddedum);
}
async function routeAndPrerender(globalContext, htmlFiles, prerenderPageIds, concurrencyLimit) {
    // Route all URLs
    await Promise.all(globalContext.prerenderPageContexts.map((pageContext) => concurrencyLimit(async () => {
        const { url, _prerenderSourceFile: prerenderSourceFile } = pageContext;
        const routeResult = await (0, route_1.route)(pageContext);
        if ('hookError' in routeResult) {
            throwPrerenderError(routeResult.hookError);
            (0, utils_1.assert)(false);
        }
        (0, utils_1.assert)((0, utils_1.hasProp)(routeResult.pageContextAddendum, '_pageId', 'null') ||
            (0, utils_1.hasProp)(routeResult.pageContextAddendum, '_pageId', 'string'));
        if (routeResult.pageContextAddendum._pageId === null) {
            // Is this assertion also true with a `onBeforeRoute()` hook?
            (0, utils_1.assert)(prerenderSourceFile);
            (0, utils_1.assertUsage)(false, `Your \`prerender()\` hook defined in \`${prerenderSourceFile}\ returns an URL \`${url}\` that doesn't match any page route. Make sure the URLs your return in your \`prerender()\` hooks always match the URL of a page.`);
        }
        (0, utils_1.assert)(routeResult.pageContextAddendum._pageId);
        (0, utils_1.objectAssign)(pageContext, routeResult.pageContextAddendum);
        const { _pageId: pageId } = pageContext;
        const pageFilesData = await (0, renderPage_1.loadPageFilesServer)(Object.assign(Object.assign({}, globalContext), { _pageId: pageId }));
        (0, utils_1.objectAssign)(pageContext, pageFilesData);
        const { documentHtml, pageContextSerialized } = await (0, renderPage_1.prerenderPage)(pageContext);
        htmlFiles.push({
            url,
            pageContext,
            htmlString: documentHtml,
            pageContextSerialized,
            doNotCreateExtraDirectory: globalContext._noExtraDir,
            pageId,
        });
        prerenderPageIds[pageId] = pageContext;
    })));
}
function warnContradictoryNoPrerenderList(prerenderPageIds, doNotPrerenderList) {
    Object.entries(prerenderPageIds).forEach(([pageId, { url, _prerenderSourceFile }]) => {
        const doNotPrerenderListHit = doNotPrerenderList.find((p) => p.pageId === pageId);
        if (doNotPrerenderListHit) {
            (0, utils_1.assert)(_prerenderSourceFile);
            (0, utils_1.assertUsage)(false, `Your \`prerender()\` hook defined in ${_prerenderSourceFile} returns the URL \`${url}\` which matches the page with \`${doNotPrerenderListHit === null || doNotPrerenderListHit === void 0 ? void 0 : doNotPrerenderListHit.pageServerFilePath}#doNotPrerender === true\`. This is contradictory: either do not set \`doNotPrerender\` or remove the URL from the list of URLs to be pre-rendered.`);
        }
    });
}
function warnMissingPages(prerenderPageIds, doNotPrerenderList, globalContext, partial) {
    globalContext._allPageIds
        .filter((pageId) => !prerenderPageIds[pageId])
        .filter((pageId) => !doNotPrerenderList.find((p) => p.pageId === pageId))
        .filter((pageId) => !(0, route_1.isErrorPage)(pageId))
        .forEach((pageId) => {
        (0, utils_1.assertWarning)(partial, `Could not pre-render page \`${pageId}.page.*\` because it has a non-static route, and no \`prerender()\` hook returned (an) URL(s) matching the page's route. Either use a \`prerender()\` hook to pre-render the page, or use the \`--partial\` option to suppress this warning.`, { onlyOnce: true });
    });
}
async function prerender404Page(htmlFiles, globalContext) {
    if (!htmlFiles.find(({ url }) => url === '/404')) {
        const result = await (0, renderPage_1.renderStatic404Page)(globalContext);
        if (result) {
            const url = '/404';
            const { documentHtml, pageContext } = result;
            htmlFiles.push({
                url,
                pageContext,
                htmlString: documentHtml,
                pageContextSerialized: null,
                doNotCreateExtraDirectory: true,
                pageId: null,
            });
        }
    }
}
async function writeHtmlFile({ url, pageContext, htmlString, pageContextSerialized, doNotCreateExtraDirectory, pageId }, root, outDir, doNotPrerenderList, concurrencyLimit, onPagePrerender, logLevel) {
    (0, utils_1.assert)(url.startsWith('/'));
    (0, utils_1.assert)(!doNotPrerenderList.find((p) => p.pageId === pageId));
    const writeJobs = [
        write(url, pageContext, '.html', htmlString, root, outDir, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel),
    ];
    if (pageContextSerialized !== null) {
        writeJobs.push(write(url, pageContext, '.pageContext.json', pageContextSerialized, root, outDir, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel));
    }
    await Promise.all(writeJobs);
}
function write(url, pageContext, fileExtension, fileContent, root, outDir, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel) {
    return concurrencyLimit(async () => {
        const fileUrl = (0, utils_1.getFileUrl)(url, fileExtension, fileExtension === '.pageContext.json' || doNotCreateExtraDirectory);
        (0, utils_1.assert)(fileUrl.startsWith('/'));
        const filePathRelative = fileUrl.slice(1).split('/').join(path_1.sep);
        (0, utils_1.assert)(!filePathRelative.startsWith(path_1.sep));
        (0, utils_1.assert)(outDir && !outDir.includes('dist/server'), { outDir });
        const filePath = (0, path_1.join)(root, outDir, filePathRelative);
        if (onPagePrerender) {
            (0, utils_1.objectAssign)(pageContext, {
                _prerenderResult: {
                    filePath,
                    fileContent,
                },
            });
            await onPagePrerender(pageContext);
        }
        else {
            const { promises } = require('fs');
            const { writeFile, mkdir } = promises;
            await mkdir((0, path_1.dirname)(filePath), { recursive: true });
            await writeFile(filePath, fileContent);
            if (logLevel === 'info') {
                let dirLog = outDir;
                if (!dirLog.endsWith(path_1.sep)) {
                    dirLog = dirLog + path_1.sep;
                }
                console.log(`${(0, kolorist_1.gray)(dirLog)}${(0, kolorist_1.blue)(filePathRelative)}`);
            }
        }
    });
}
function normalizePrerenderResult(prerenderResult, prerenderSourceFile) {
    if (Array.isArray(prerenderResult)) {
        return prerenderResult.map(normalize);
    }
    else {
        return [normalize(prerenderResult)];
    }
    function normalize(prerenderElement) {
        if (typeof prerenderElement === 'string')
            return { url: prerenderElement, pageContext: null };
        const errMsg1 = `The \`prerender()\` hook defined in \`${prerenderSourceFile}\` returned an invalid value`;
        const errMsg2 = 'Make sure your `prerender()` hook returns an object `{ url, pageContext }` or an array of such objects.';
        (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(prerenderElement), `${errMsg1}. ${errMsg2}`);
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'url'), `${errMsg1}: \`url\` is missing. ${errMsg2}`);
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'url', 'string'), `${errMsg1}: \`url\` should be a string (but we got \`typeof url === "${typeof prerenderElement.url}"\`).`);
        (0, utils_1.assertUsage)(prerenderElement.url.startsWith('/'), `${errMsg1}: the \`url\` with value \`${prerenderElement.url}\` doesn't start with \`/\`. Make sure each URL starts with \`/\`.`);
        Object.keys(prerenderElement).forEach((key) => {
            (0, utils_1.assertUsage)(key === 'url' || key === 'pageContext', `${errMsg1}: unexpected object key \`${key}\` ${errMsg2}`);
        });
        if (!(0, utils_1.hasProp)(prerenderElement, 'pageContext')) {
            prerenderElement['pageContext'] = null;
        }
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'pageContext', 'object'), `The \`prerender()\` hook exported by ${prerenderSourceFile} returned an invalid \`pageContext\` value: make sure \`pageContext\` is a plain JavaScript object.`);
        return prerenderElement;
    }
}
function checkOutdatedOptions(options) {
    ;
    ['noExtraDir', 'partial', 'parallel'].forEach((prop) => {
        (0, utils_1.assertUsage)(options[prop] === undefined, `[prerender()] Option \`${prop}\` is deprecated. Define \`${prop}\` in \`vite.config.js\` instead. See https://vite-plugin-ssr.com/config`);
    });
    ['base', 'root', 'outDir'].forEach((prop) => {
        (0, utils_1.assertWarning)(options[prop] === undefined, `[prerender()] Option \`${prop}\` is deprecated and has no effect (vite-plugin-ssr now automatically determines \`${prop}\`)`, {
            onlyOnce: true,
        });
    });
    const { partial, noExtraDir, root, outDir, parallel } = options;
    (0, utils_1.assertUsage)(partial === undefined || partial === true || partial === false, '[prerender()] Option `partial` should be a boolean.');
    (0, utils_1.assertUsage)(noExtraDir === undefined || noExtraDir === true || noExtraDir === false, '[prerender()] Option `noExtraDir` should be a boolean.');
    (0, utils_1.assertUsage)(root === undefined || typeof root === 'string', '[prerender()] Option `root` should be a string.');
    (0, utils_1.assertUsage)(root === undefined || (0, path_1.isAbsolute)(root), '[prerender()] The path `root` is not absolute. Make sure to provide an absolute path.');
    (0, utils_1.assertUsage)(outDir === undefined || typeof outDir === 'string', '[prerender()] Option `outDir` should be a string.');
    (0, utils_1.assertUsage)(parallel === undefined || parallel, `[prerender()] Option \`parallel\` should be a number \`>=1\` but we got \`${parallel}\`.`);
}
function setProductionEnvVar() {
    // The statement `process.env['NODE_ENV'] = 'production'` chokes webpack v4 (which Cloudflare Workers uses)
    const proc = process;
    const { env } = proc;
    env['NODE_ENV'] = 'production';
}
function throwPrerenderError(err) {
    if ((0, utils_1.hasProp)(err, 'stack')) {
        throw err;
    }
    else {
        throw new Error(err);
    }
}
