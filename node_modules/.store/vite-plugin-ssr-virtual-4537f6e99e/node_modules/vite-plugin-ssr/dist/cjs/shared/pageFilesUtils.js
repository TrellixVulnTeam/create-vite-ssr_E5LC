"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasPageExport = exports.getExportNames = exports.isHtmlOnlyPage = void 0;
const utils_1 = require("./utils");
function isHtmlOnlyPage(pageId, pageFilesAll, isClientSide) {
    // The `.page.client.js`/`.page.js` files that should, potentially, be loaded in the browser
    const pageFilesClientCandidates = pageFilesAll.filter((p) => (p.fileType === '.page.client' || p.fileType === '.page') && p.isRelevant(pageId));
    const hasPage = pageFilesClientCandidates.some((p) => hasPageExport(p, isClientSide));
    const hasRender = pageFilesClientCandidates.some((p) => getExportNames(p, isClientSide).includes('render'));
    const isHtmlOnly = !hasPage || !hasRender;
    return { isHtmlOnly, pageFilesClientCandidates };
}
exports.isHtmlOnlyPage = isHtmlOnlyPage;
function getExportNames(pageFile, isClientSide) {
    if (pageFile.fileType === '.page.client') {
        // We assume `pageFile.loadExportNames()` was already called
        (0, utils_1.assert)(pageFile.exportNames, pageFile.filePath);
        return pageFile.exportNames;
    }
    if (pageFile.fileType === '.page') {
        if (pageFile.exportNames) {
            return pageFile.exportNames;
        }
        // In order to not break HMR, the client-side should not retrieve the export names from `pageFile.fileExports`.
        if (!isClientSide && pageFile.fileExports) {
            return Object.keys(pageFile.fileExports);
        }
        (0, utils_1.assert)(false, pageFile.filePath);
    }
    (0, utils_1.assert)(false);
}
exports.getExportNames = getExportNames;
function hasPageExport(pageFile, isClientSide) {
    const exportNames = getExportNames(pageFile, isClientSide);
    return exportNames.includes('default') || exportNames.includes('Page');
}
exports.hasPageExport = hasPageExport;
