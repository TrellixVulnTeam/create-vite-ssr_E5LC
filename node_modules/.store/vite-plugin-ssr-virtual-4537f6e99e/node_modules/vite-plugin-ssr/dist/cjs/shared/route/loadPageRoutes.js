"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPageRoutes = void 0;
const error_page_1 = require("./error-page");
const utils_1 = require("./utils");
const resolveFilesystemRoute_1 = require("./resolveFilesystemRoute");
async function loadPageRoutes(pageContext) {
    let onBeforeRouteHook = null;
    const filesystemRoots = [];
    await Promise.all(pageContext._pageFilesAll.filter((p) => p.fileType === '.page.route').map((p) => { var _a; return (_a = p.loadFile) === null || _a === void 0 ? void 0 : _a.call(p); }));
    pageContext._pageFilesAll
        .filter((p) => p.fileType === '.page.route' && p.isDefaultPageFile)
        .map(async ({ filePath, fileExports }) => {
        (0, utils_1.assert)(fileExports);
        if ('onBeforeRoute' in fileExports) {
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'onBeforeRoute', 'function'), `\`export { onBeforeRoute }\` of ${filePath} should be a function.`);
            const { onBeforeRoute } = fileExports;
            onBeforeRouteHook = { filePath, onBeforeRoute };
        }
        if ('filesystemRoutingRoot' in fileExports) {
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'filesystemRoutingRoot', 'string'), `\`export { filesystemRoutingRoot }\` of ${filePath} should be a string.`);
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'filesystemRoutingRoot', 'string'), `\`export { filesystemRoutingRoot }\` of ${filePath} is \`'${fileExports.filesystemRoutingRoot}'\` but it should start with a leading slash \`/\`.`);
            filesystemRoots.push({
                rootPath: dirname(filePath),
                rootValue: fileExports.filesystemRoutingRoot,
            });
        }
    });
    const allPageIds = pageContext._allPageIds;
    const pageRoutes = [];
    allPageIds
        .filter((pageId) => !(0, error_page_1.isErrorPage)(pageId))
        .map(async (pageId) => {
        const filesystemRoute = (0, resolveFilesystemRoute_1.getFilesystemRoute)(pageId, filesystemRoots);
        (0, utils_1.assert)(filesystemRoute.startsWith('/'));
        (0, utils_1.assert)(!filesystemRoute.endsWith('/') || filesystemRoute === '/');
        const pageRoute = {
            pageId,
            filesystemRoute,
        };
        const pageRouteFile = pageContext._pageFilesAll.find((p) => p.pageId === pageId && p.fileType === '.page.route');
        if (pageRouteFile) {
            const { filePath, fileExports } = pageRouteFile;
            (0, utils_1.assert)(fileExports);
            (0, utils_1.assertUsage)('default' in fileExports, `${filePath} should have a default export.`);
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'default', 'string') || (0, utils_1.hasProp)(fileExports, 'default', 'function'), `The default export of ${filePath} should be a string or a function.`);
            (0, utils_1.assertUsage)(!('iKnowThePerformanceRisksOfAsyncRouteFunctions' in fileExports) ||
                (0, utils_1.hasProp)(fileExports, 'iKnowThePerformanceRisksOfAsyncRouteFunctions', 'boolean'), `The export \`iKnowThePerformanceRisksOfAsyncRouteFunctions\` of ${filePath} should be a boolean.`);
            const routeValue = fileExports.default;
            (0, utils_1.objectAssign)(pageRoute, {
                pageRouteFile: { filePath, fileExports, routeValue },
            });
            pageRoutes.push(pageRoute);
        }
        else {
            pageRoutes.push(pageRoute);
        }
    });
    return { pageRoutes, onBeforeRouteHook };
}
exports.loadPageRoutes = loadPageRoutes;
function dirname(filePath) {
    (0, utils_1.assert)(filePath.startsWith('/'));
    (0, utils_1.assert)(!filePath.endsWith('/'));
    const paths = filePath.split('/');
    const dirPath = (0, utils_1.slice)(paths, 0, -1).join('/') || '/';
    (0, utils_1.assert)(dirPath.startsWith('/'));
    (0, utils_1.assert)(!dirPath.endsWith('/') || dirPath === '/');
    return dirPath;
}
