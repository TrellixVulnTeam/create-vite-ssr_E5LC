/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _require = require('./RelayReactCache'),
    getCacheForType = _require.getCacheForType,
    getCacheSignal = _require.getCacheSignal;

var invariant = require('invariant');

var _require2 = require('relay-runtime'),
    fetchQueryInternal = _require2.__internal.fetchQuery;

var warning = require("fbjs/lib/warning");

var DEFAULT_FETCH_POLICY = 'store-or-network';

function createQueryCache() {
  return new Map();
}

function getQueryCacheKey(operation, fetchPolicy, renderPolicy) {
  var cacheIdentifier = "".concat(fetchPolicy, "-").concat(renderPolicy, "-").concat(operation.request.identifier);
  return cacheIdentifier;
}

function constructQueryResult(operation) {
  var rootFragmentRef = {
    __id: operation.fragment.dataID,
    __fragments: (0, _defineProperty2["default"])({}, operation.fragment.node.name, operation.request.variables),
    __fragmentOwner: operation.request
  };
  return {
    fragmentNode: operation.request.node.fragment,
    fragmentRef: rootFragmentRef
  };
}

function getQueryResultOrFetchQuery_REACT_CACHE(environment, queryOperationDescriptor) {
  var fetchPolicy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_FETCH_POLICY;
  var maybeRenderPolicy = arguments.length > 3 ? arguments[3] : undefined;
  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
  var cache = getCacheForType(createQueryCache);
  var cacheKey = getQueryCacheKey(queryOperationDescriptor, fetchPolicy, renderPolicy);
  var entry = cache.get(cacheKey);

  if (entry === undefined) {
    // Initiate a query to fetch the data if needed:
    entry = onCacheMiss(environment, queryOperationDescriptor, fetchPolicy, renderPolicy, function (newCacheEntry) {
      cache.set(cacheKey, newCacheEntry);
    });
    cache.set(cacheKey, entry); // Since this is the first time rendering, retain the query. React will
    // trigger the abort signal when this cache entry is no longer needed.

    var retention = environment.retain(queryOperationDescriptor);
    var abortSignal = getCacheSignal();
    abortSignal.addEventListener('abort', function () {
      retention.dispose();
      cache["delete"](cacheKey);
    }, {
      once: true
    });
  }

  switch (entry.status) {
    case 'pending':
      throw entry.promise;

    case 'rejected':
      throw entry.error;

    case 'resolved':
      return entry.result;
  }

  !false ? process.env.NODE_ENV !== "production" ? invariant(false, 'switch statement should be exhaustive') : invariant(false) : void 0;
}

function onCacheMiss(environment, operation, fetchPolicy, renderPolicy, updateCache) {
  // NB: Besides checking if the data is available, calling `check` will write missing
  // data to the store using any missing data handlers specified in the environment.
  var queryAvailability = environment.check(operation);
  var queryStatus = queryAvailability.status;
  var hasFullQuery = queryStatus === 'available';
  var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';
  var shouldFetch;
  var shouldRenderNow;

  switch (fetchPolicy) {
    case 'store-only':
      {
        shouldFetch = false;
        shouldRenderNow = true;
        break;
      }

    case 'store-or-network':
      {
        shouldFetch = !hasFullQuery;
        shouldRenderNow = canPartialRender;
        break;
      }

    case 'store-and-network':
      {
        shouldFetch = true;
        shouldRenderNow = canPartialRender;
        break;
      }

    case 'network-only':
    default:
      {
        shouldFetch = true;
        shouldRenderNow = false;
        break;
      }
  }

  var promise = shouldFetch ? executeOperationAndKeepUpToDate(environment, operation, updateCache) : undefined;

  if (shouldRenderNow) {
    return {
      status: 'resolved',
      result: constructQueryResult(operation)
    };
  } else {
    !promise ? process.env.NODE_ENV !== "production" ? invariant(false, 'Should either fetch or render (or both), otherwise we would suspend forever.') : invariant(false) : void 0;
    return {
      status: 'pending',
      promise: promise
    };
  }
}

function executeOperationAndKeepUpToDate(environment, operation, updateCache) {
  var resolvePromise;
  var promise = new Promise(function (r) {
    resolvePromise = r;
  }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.

  promise.displayName = 'Relay(' + operation.request.node.operation.name + ')';
  var isFirstPayload = true; // FIXME We may still need to cancel network requests for live queries.

  var fetchObservable = fetchQueryInternal(environment, operation);
  fetchObservable.subscribe({
    start: function start(subscription) {},
    error: function error(_error) {
      if (isFirstPayload) {
        updateCache({
          status: 'rejected',
          error: _error
        });
      } else {
        // TODO:T92030819 Remove this warning and actually throw the network error
        // To complete this task we need to have a way of precisely tracking suspendable points
        process.env.NODE_ENV !== "production" ? warning(false, 'getQueryResultOrFetchQuery: An incremental payload for query `%` returned an error: `%`:`%`.', operation.request.node.operation.name, _error.message, _error.stack) : void 0;
      }

      resolvePromise();
      isFirstPayload = false;
    },
    next: function next(response) {
      // Stop suspending on the first payload because of streaming, defer, etc.
      updateCache({
        status: 'resolved',
        result: constructQueryResult(operation)
      });
      resolvePromise();
      isFirstPayload = false;
    },
    complete: function complete() {
      updateCache({
        status: 'resolved',
        result: constructQueryResult(operation)
      });
      resolvePromise();
      isFirstPayload = false;
    }
  });
  return promise;
}

module.exports = getQueryResultOrFetchQuery_REACT_CACHE;