/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @emails oncall+relay
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _createForOfIteratorHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/createForOfIteratorHelper"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var useRelayEnvironment = require('../useRelayEnvironment');

var getQueryResultOrFetchQuery = require('./getQueryResultOrFetchQuery_REACT_CACHE');

var invariant = require('invariant');

var _require = require('react'),
    useDebugValue = _require.useDebugValue,
    useEffect = _require.useEffect,
    useMemo = _require.useMemo,
    useRef = _require.useRef,
    useState = _require.useState;

var _require2 = require('relay-runtime'),
    areEqualSelectors = _require2.areEqualSelectors,
    createOperationDescriptor = _require2.createOperationDescriptor,
    getPendingOperationsForFragment = _require2.getPendingOperationsForFragment,
    getSelector = _require2.getSelector,
    getVariablesFromFragment = _require2.getVariablesFromFragment,
    handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors,
    recycleNodesInto = _require2.recycleNodesInto;

function isMissingData(state) {
  if (state.kind === 'bailout') {
    return false;
  } else if (state.kind === 'singular') {
    return state.snapshot.isMissingData;
  } else {
    return state.snapshots.some(function (s) {
      return s.isMissingData;
    });
  }
}

function getMissingClientEdges(state) {
  if (state.kind === 'bailout') {
    return null;
  } else if (state.kind === 'singular') {
    var _state$snapshot$missi;

    return (_state$snapshot$missi = state.snapshot.missingClientEdges) !== null && _state$snapshot$missi !== void 0 ? _state$snapshot$missi : null;
  } else {
    var edges = null;

    var _iterator = (0, _createForOfIteratorHelper2["default"])(state.snapshots),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var snapshot = _step.value;

        if (snapshot.missingClientEdges) {
          var _edges;

          edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : [];

          var _iterator2 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingClientEdges),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var edge = _step2.value;
              edges.push(edge);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return edges;
  }
}

function handlePotentialSnapshotErrorsForState(environment, state) {
  if (state.kind === 'singular') {
    handlePotentialSnapshotErrors(environment, state.snapshot.missingRequiredFields, state.snapshot.relayResolverErrors);
  } else if (state.kind === 'plural') {
    var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.snapshots),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var snapshot = _step3.value;
        handlePotentialSnapshotErrors(environment, snapshot.missingRequiredFields, snapshot.relayResolverErrors);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
}

function handleMissedUpdates(environment, state, setState) {
  if (state.kind === 'bailout') {
    return;
  }

  var currentEpoch = environment.getStore().getEpoch();

  if (currentEpoch === state.epoch) {
    return;
  } // The store has updated since we rendered (without us being subscribed yet),
  // so check for any updates to the data we're rendering:


  if (state.kind === 'singular') {
    var currentSnapshot = environment.lookup(state.snapshot.selector);
    var updatedData = recycleNodesInto(state.snapshot.data, currentSnapshot.data);

    if (updatedData !== state.snapshot.data) {
      setState({
        kind: 'singular',
        snapshot: currentSnapshot,
        epoch: currentEpoch
      });
    }
  } else {
    var updates = null;

    for (var index = 0; index < state.snapshots.length; index++) {
      var snapshot = state.snapshots[index];

      var _currentSnapshot = environment.lookup(snapshot.selector);

      var _updatedData = recycleNodesInto(snapshot.data, _currentSnapshot.data);

      if (_updatedData !== snapshot.data) {
        updates = updates === null ? new Array(state.snapshots.length) : updates;
        updates[index] = snapshot;
      }
    }

    if (updates !== null) {
      var theUpdates = updates; // preserve flow refinement.

      setState(function (existing) {
        !(existing.kind === 'plural') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot go from singular to plural or from bailout to plural.') : invariant(false) : void 0;
        var updated = (0, _toConsumableArray2["default"])(existing.snapshots);

        for (var _index = 0; _index < theUpdates.length; _index++) {
          var updatedSnapshot = theUpdates[_index];

          if (updatedSnapshot) {
            updated[_index] = updatedSnapshot;
          }
        }

        return {
          kind: 'plural',
          snapshots: updated,
          epoch: currentEpoch
        };
      });
    }
  }
}

function handleMissingClientEdge(environment, parentFragmentNode, parentFragmentRef, missingClientEdgeRequestInfo, queryOptions) {
  var originalVariables = getVariablesFromFragment(parentFragmentNode, parentFragmentRef);
  var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
    id: missingClientEdgeRequestInfo.clientEdgeDestinationID // TODO should be a reserved name

  });
  var queryOperationDescriptor = createOperationDescriptor(missingClientEdgeRequestInfo.request, variables, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.networkCacheConfig); // This may suspend. We don't need to do anything with the results; all we're
  // doing here is started the query if needed and retaining and releasing it
  // according to the component mount/suspense cycle; getQueryResultOrFetchQuery
  // already handles this by itself.

  getQueryResultOrFetchQuery(environment, queryOperationDescriptor, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy);
}

function subscribeToSnapshot(environment, state, setState) {
  if (state.kind === 'bailout') {
    return function () {};
  } else if (state.kind === 'singular') {
    var disposable = environment.subscribe(state.snapshot, function (latestSnapshot) {
      setState({
        kind: 'singular',
        snapshot: latestSnapshot,
        epoch: environment.getStore().getEpoch()
      });
    });
    return function () {
      disposable.dispose();
    };
  } else {
    var disposables = state.snapshots.map(function (snapshot, index) {
      return environment.subscribe(snapshot, function (latestSnapshot) {
        setState(function (existing) {
          !(existing.kind === 'plural') ? process.env.NODE_ENV !== "production" ? invariant(false, 'Cannot go from singular to plural or from bailout to plural.') : invariant(false) : void 0;
          var updated = (0, _toConsumableArray2["default"])(existing.snapshots);
          updated[index] = latestSnapshot;
          return {
            kind: 'plural',
            snapshots: updated,
            epoch: environment.getStore().getEpoch()
          };
        });
      });
    });
    return function () {
      var _iterator4 = (0, _createForOfIteratorHelper2["default"])(disposables),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var d = _step4.value;
          d.dispose();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    };
  }
}

function getFragmentState(environment, fragmentSelector) {
  if (fragmentSelector == null) {
    return {
      kind: 'bailout'
    };
  } else if (fragmentSelector.kind === 'PluralReaderSelector') {
    return {
      kind: 'plural',
      snapshots: fragmentSelector.selectors.map(function (s) {
        return environment.lookup(s);
      }),
      epoch: environment.getStore().getEpoch()
    };
  } else {
    return {
      kind: 'singular',
      snapshot: environment.lookup(fragmentSelector),
      epoch: environment.getStore().getEpoch()
    };
  }
} // fragmentNode cannot change during the lifetime of the component, though fragmentRef may change.


function useFragmentInternal_REACT_CACHE(fragmentNode, fragmentRef, hookDisplayName, queryOptions, fragmentKey) {
  var _fragmentNode$metadat;

  var fragmentSelector = getSelector(fragmentNode, fragmentRef);

  if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {
    !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;
  } else {
    !!Array.isArray(fragmentRef) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` not to be ' + 'an array, instead got `%s`. Add `@relay(plural: true)` ' + 'to fragment `%s` to allow the prop to be an array.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;
  }

  !(fragmentRef == null || fragmentSelector != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, hookDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : "the `".concat(fragmentKey, "`"), hookDisplayName) : invariant(false) : void 0;
  var environment = useRelayEnvironment();

  var _useState = useState(function () {
    return getFragmentState(environment, fragmentSelector);
  }),
      rawState = _useState[0],
      setState = _useState[1];

  var _useState2 = useState(fragmentSelector),
      previousFragmentSelector = _useState2[0],
      setPreviousFragmentSelector = _useState2[1];

  if (!areEqualSelectors(fragmentSelector, previousFragmentSelector)) {
    setPreviousFragmentSelector(fragmentSelector);
    setState(getFragmentState(environment, fragmentSelector));
  }

  var state;

  if (fragmentRef == null) {
    state = {
      kind: 'bailout'
    };
  } else if (rawState.kind === 'plural' && rawState.snapshots.length === 0) {
    state = {
      kind: 'bailout'
    };
  } else {
    state = rawState;
  } // Handle the queries for any missing client edges; this may suspend.
  // FIXME handle client edges in parallel.


  var missingClientEdges = getMissingClientEdges(state);

  if (missingClientEdges === null || missingClientEdges === void 0 ? void 0 : missingClientEdges.length) {
    var _iterator5 = (0, _createForOfIteratorHelper2["default"])(missingClientEdges),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var edge = _step5.value;
        handleMissingClientEdge(environment, fragmentNode, fragmentRef, edge, queryOptions);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
  }

  if (isMissingData(state)) {
    // Suspend if an active operation bears on this fragment, either the
    // fragment's owner or some other mutation etc. that could affect it:
    !(fragmentSelector != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'refinement, see invariants above') : invariant(false) : void 0;
    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
    var pendingOperationsResult = getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner);

    if (pendingOperationsResult) {
      throw pendingOperationsResult.promise;
    } // Report required fields only if we're not suspending, since that means
    // they're missing even though we are out of options for possibly fetching them:


    handlePotentialSnapshotErrorsForState(environment, state);
  } // Subscriptions:


  var isMountedRef = useRef(false);
  var isListeningForUpdatesRef = useRef(true);

  function enableStoreUpdates() {
    isListeningForUpdatesRef.current = true;
    handleMissedUpdates(environment, state, setState);
  }

  function disableStoreUpdates() {
    isListeningForUpdatesRef.current = false;
  }

  useEffect(function () {
    var wasAlreadySubscribed = isMountedRef.current;
    isMountedRef.current = true;

    if (!wasAlreadySubscribed) {
      handleMissedUpdates(environment, state, setState);
    }

    return subscribeToSnapshot(environment, state, setState);
  }, [environment, state]);
  var data = useMemo(function () {
    return state.kind === 'bailout' ? {} : state.kind === 'singular' ? state.snapshot.data : state.snapshots.map(function (s) {
      return s.data;
    });
  }, [state]);

  if (process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useDebugValue({
      fragment: fragmentNode.name,
      data: data
    });
  }

  return {
    data: data,
    disableStoreUpdates: disableStoreUpdates,
    enableStoreUpdates: enableStoreUpdates
  };
}

module.exports = useFragmentInternal_REACT_CACHE;